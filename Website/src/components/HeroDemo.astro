---
/* HeroDemo — Two-panel "Before → After" transformation demo */
---

<div class="hero-demo max-w-[900px] mx-auto mb-16">
  <!-- Two-panel container -->
  <div
    class="demo-panels-wrapper"
    aria-live="polite"
    aria-label="Voice-to-text transformation demo"
  >
    <!-- LEFT PANEL — Raw input -->
    <div class="demo-panel demo-panel-left rounded-xl border border-border overflow-hidden relative">
      <!-- Header: Voice Input -->
      <div class="panel-header panel-header-left">
        <svg class="header-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="6.5" y="2" width="3" height="7" rx="1.5" stroke="currentColor" stroke-width="1.5" fill="none"/>
          <path d="M4 7.5C4 9.985 6.015 12 8.5 12C10.985 12 13 9.985 13 7.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="8" y1="12" x2="8" y2="14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="6" y1="14" x2="10" y2="14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
        <span class="header-label">You Speak</span>
        <!-- Recording overlay bubble (styled like actual overlay) -->
        <div class="recording-overlay" aria-hidden="true">
          <!-- SVG Canvas for overlay -->
          <svg class="overlay-svg" viewBox="0 0 106 26" preserveAspectRatio="none">
            <!-- Glow halo -->
            <rect class="overlay-halo" x="2" y="2" width="102" height="22" rx="13" />
            <!-- Main bubble background -->
            <rect class="overlay-bg" x="3" y="3" width="100" height="20" rx="12" />
            <!-- Top gloss -->
            <rect class="overlay-gloss" x="4" y="3.5" width="98" height="10" rx="6" />
            <!-- Inner rim -->
            <rect class="overlay-rim" x="3.5" y="3.5" width="99" height="19" rx="11.5" />
          </svg>
          <!-- Pulsing circles around mic -->
          <div class="pulse-circles">
            <span class="pulse-ring pulse-ring-1"></span>
            <span class="pulse-ring pulse-ring-2"></span>
            <span class="pulse-ring pulse-ring-3"></span>
            <span class="mic-dot"></span>
          </div>
          <!-- Traveling wave -->
          <svg class="wave-svg" viewBox="0 0 44 26" preserveAspectRatio="none">
            <path class="wave-path" d="" stroke-width="1.6" stroke-linecap="round" fill="none" />
          </svg>
          <!-- Timer display -->
          <span class="overlay-timer">0:03</span>
        </div>
      </div>
      <div class="p-4 md:p-6">
        <div class="demo-raw font-mono text-text-secondary text-sm md:text-base leading-relaxed">
          <span class="demo-raw-text"></span>
          <span class="demo-caret"></span>
        </div>
      </div>
    </div>

    <!-- CONNECTOR ARROW -->
    <div class="demo-connector" aria-hidden="true">
      <div class="connector-line"></div>
      <div class="connector-arrow">→</div>
      <div class="connector-label font-mono text-xs text-text-tertiary">
        <span class="connector-tech">AI transcribes → AI cleans up</span>
      </div>
    </div>

    <!-- RIGHT PANEL — Clean output -->
    <div class="demo-panel demo-panel-right rounded-xl border border-border overflow-hidden relative">
      <!-- Header: Clean Output -->
      <div class="panel-header panel-header-right">
        <svg class="header-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M13 4L6 11L3 8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span class="header-label">QuickSay Types</span>
      </div>
      <div class="p-4 md:p-6">
        <div class="demo-clean font-body text-text-primary text-sm md:text-base leading-relaxed">
          <span class="demo-clean-text"></span>
        </div>
      </div>

      <!-- Shimmer overlay (only on right panel) -->
      <div class="demo-shimmer absolute inset-0 pointer-events-none z-10" aria-hidden="true"></div>
    </div>
  </div>

  <!-- Persona tabs -->
  <div class="demo-tabs flex gap-2 mt-4 justify-center flex-wrap" role="tablist" aria-label="Demo persona">
    <button class="demo-tab active" role="tab" aria-selected="true" data-tab="developer">Developer</button>
    <button class="demo-tab" role="tab" aria-selected="false" data-tab="email">Email</button>
    <button class="demo-tab" role="tab" aria-selected="false" data-tab="notes">Notes</button>
    <button class="demo-tab" role="tab" aria-selected="false" data-tab="creative">Creative</button>
  </div>

  <!-- noscript fallback -->
  <noscript>
    <div class="rounded-xl border border-border overflow-hidden p-6 md:p-8 mt-4" style="background: #0e0e10;">
      <p class="font-body text-text-primary text-sm md:text-base leading-relaxed">
        Create a function that takes user input, validates it against the schema, and returns either the cleaned data or an error message. Handle the edge case where the input is null.
      </p>
      <p class="font-mono text-xs text-text-tertiary mt-4">AI transcription &rarr; AI cleanup &rarr; perfect text</p>
    </div>
  </noscript>
</div>

<style>
  /* Two-panel layout */
  .demo-panels-wrapper {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 1rem;
    align-items: center;
    min-height: 180px;
  }

  /* Stack on mobile */
  @media (max-width: 767px) {
    .demo-panels-wrapper {
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }
  }

  /* Individual panels */
  .demo-panel {
    background: #1c1c20; /* surface color */
    min-height: 160px;
    transition: box-shadow 0.5s ease, transform 0.3s ease;
  }

  .demo-panel-left {
    background: #1a1a1e; /* slightly darker for contrast */
  }

  .demo-panel-right.transformed {
    box-shadow: 0 0 50px rgba(34, 211, 197, 0.25);
  }

  /* Panel headers */
  .panel-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(0, 0, 0, 0.2);
  }

  .panel-header-left {
    border-bottom-color: rgba(255, 120, 60, 0.15);
  }

  .panel-header-right {
    border-bottom-color: rgba(34, 211, 197, 0.15);
  }

  .header-icon {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
  }

  .panel-header-left .header-icon {
    color: var(--accent-orange);
  }

  .panel-header-right .header-icon {
    color: var(--accent-teal);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .panel-header-right.active .header-icon {
    opacity: 1;
  }

  .header-label {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-tertiary);
  }

  .panel-header-left .header-label {
    color: rgba(255, 120, 60, 0.7);
  }

  .panel-header-right .header-label {
    color: rgba(34, 211, 197, 0.5);
    transition: color 0.3s ease;
  }

  .panel-header-right.active .header-label {
    color: rgba(34, 211, 197, 0.8);
  }

  /* Recording overlay (styled like actual QuickSay overlay) */
  .recording-overlay {
    position: relative;
    width: 106px;
    height: 26px;
    margin-left: auto;
    opacity: 0;
    transform: scale(0.98);
    transition: opacity 0.15s ease, transform 0.15s ease; /* FASTER appearance */
  }

  .recording-overlay.active {
    opacity: 1;
    transform: scale(1);
  }

  /* Overlay SVG layers */
  .overlay-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  /* Glow halo (outer) - ORANGE for demo */
  .overlay-halo {
    fill: none;
    stroke: rgba(255, 120, 60, 0.15);
    stroke-width: 6;
  }

  /* Main bubble background */
  .overlay-bg {
    fill: rgba(15, 15, 18, 0.85);
  }

  /* Top gloss */
  .overlay-gloss {
    fill: rgba(26, 26, 33, 0.4);
  }

  /* Inner rim */
  .overlay-rim {
    fill: none;
    stroke: rgba(255, 255, 255, 0.2);
    stroke-width: 1;
  }

  /* Pulsing circles (mic icon area) */
  .pulse-circles {
    position: absolute;
    left: 16px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
  }

  .pulse-ring {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 1px solid rgba(255, 120, 60, 0.3);
    pointer-events: none;
  }

  .recording-overlay.active .pulse-ring {
    animation: pulse-expand 1.8s ease-out infinite;
  }

  .pulse-ring-1 {
    width: 8px;
    height: 8px;
    animation-delay: 0s;
  }

  .pulse-ring-2 {
    width: 12px;
    height: 12px;
    animation-delay: 0.3s;
  }

  .pulse-ring-3 {
    width: 16px;
    height: 16px;
    animation-delay: 0.6s;
  }

  @keyframes pulse-expand {
    0% {
      transform: translate(-50%, -50%) scale(0.8);
      opacity: 0.5;
    }
    50% {
      opacity: 0.3;
    }
    100% {
      transform: translate(-50%, -50%) scale(1.3);
      opacity: 0;
    }
  }

  /* Mic dot (center) */
  .mic-dot {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #f0f0f3;
  }

  /* Traveling wave SVG */
  .wave-svg {
    position: absolute;
    left: 30px;
    top: 0;
    width: 44px;
    height: 26px;
    pointer-events: none;
  }

  .wave-path {
    stroke: rgba(255, 120, 60, 0.9);
  }

  /* Timer text */
  .overlay-timer {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    font-family: 'Segoe UI', 'DM Sans', sans-serif;
    font-size: 9px;
    font-weight: 400;
    color: #f0f0f3;
    letter-spacing: 0.02em;
  }

  /* Raw text with typing caret */
  .demo-raw {
    background: rgba(255, 120, 60, 0.04);
    border-left: 2px solid rgba(255, 120, 60, 0.4);
    padding: 12px;
    padding-left: 14px;
    border-radius: 6px;
    min-height: 100px;
  }

  .demo-caret {
    display: inline-block;
    width: 2px;
    height: 1.2em;
    background: rgba(255, 120, 60, 0.7);
    vertical-align: text-bottom;
    margin-left: 2px;
    animation: caret-blink 0.6s step-end infinite;
  }

  .demo-caret.hidden {
    display: none;
  }

  @keyframes caret-blink {
    from, to { opacity: 1; }
    50% { opacity: 0; }
  }

  /* Clean text */
  .demo-clean {
    background: rgba(34, 211, 197, 0.04);
    border-left: 2px solid rgba(34, 211, 197, 0.6);
    padding: 12px;
    padding-left: 14px;
    border-radius: 6px;
    min-height: 100px;
    opacity: 0;
    transform: scale(0.98);
    transition: opacity 0.3s ease, transform 0.3s ease;
  }

  .demo-clean.visible {
    opacity: 1;
    transform: scale(1);
  }

  /* Connector arrow */
  .demo-connector {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
    opacity: 0;
    transition: opacity 0.4s ease;
  }

  .demo-connector.visible {
    opacity: 1;
  }

  @media (max-width: 767px) {
    .demo-connector {
      transform: rotate(90deg);
      margin: -0.5rem 0;
    }
  }

  .connector-arrow {
    font-size: 2rem;
    font-weight: 700;
    color: var(--accent-teal);
    line-height: 1;
  }

  .connector-label {
    opacity: 0.7;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    white-space: nowrap;
    font-size: 0.75rem;
    color: var(--accent-teal);
  }

  @media (max-width: 767px) {
    .connector-label {
      transform: rotate(-90deg);
      font-size: 0.75rem;
    }
  }

  /* Shimmer sweep (only on right panel) */
  .demo-shimmer {
    opacity: 0;
    background: linear-gradient(90deg, transparent 0%, rgba(34, 211, 197, 0.6) 50%, transparent 100%);
    background-size: 200% 100%;
    border-radius: inherit;
  }

  .demo-shimmer.active {
    opacity: 1;
    animation: shimmer-sweep 0.7s ease-in-out forwards;
  }

  @keyframes shimmer-sweep {
    from { background-position: 200% 0; }
    to { background-position: -200% 0; }
  }

  /* Tabs */
  .demo-tab {
    padding: 6px 16px;
    border-radius: 8px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-secondary);
    background: transparent;
    border: 1px solid transparent;
    cursor: pointer;
    transition: color 0.15s ease, border-color 0.15s ease, background 0.15s ease;
  }

  .demo-tab:hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.04);
  }

  .demo-tab.active {
    color: var(--accent-teal);
    border-color: var(--accent-teal);
    background: rgba(34, 211, 197, 0.06);
  }

  .demo-tab:focus-visible {
    outline: 2px solid var(--accent-teal);
    outline-offset: 2px;
  }

  /* Reduced motion: show static final state */
  @media (prefers-reduced-motion: reduce) {
    .recording-overlay.active .pulse-ring {
      animation: none;
    }

    .demo-caret {
      animation: none;
    }

    .demo-shimmer.active {
      animation: none;
      opacity: 0;
    }

    .demo-panel {
      transition: none;
    }

    .demo-clean {
      transition: none;
    }

    .recording-overlay {
      transition: none;
    }

    .demo-connector {
      transition: none;
    }

    .panel-header-right .header-icon {
      transition: none;
    }

    .panel-header-right .header-label {
      transition: none;
    }

    .demo-tab {
      transition: none;
    }
  }
</style>

<script>
  const PERSONAS = {
    developer: {
      raw: "so um basically what i need is a function that takes the user input and validates it against the schema and then returns either the cleaned data or an error message i think we should also handle the edge case where the input is null",
      clean: "Create a function that takes user input, validates it against the schema, and returns either the cleaned data or an error message. Handle the edge case where the input is null."
    },
    email: {
      raw: "hey sarah so i was thinking about the timeline for the q2 launch and i think we might need to push it back a week because the design team is still waiting on the final assets from the client and theres no way well have everything reviewed by friday",
      clean: "Hi Sarah, I think we may need to push the Q2 launch back by one week. The design team is still waiting on final assets from the client, and we won't have everything reviewed by Friday. Let me know your thoughts."
    },
    notes: {
      raw: "meeting with jake about the new feature um he wants to add real time collaboration but i think we should focus on fixing the existing bugs first especially the one where the app crashes on large files also need to follow up with marketing about the blog post deadline",
      clean: "\u2022 Jake wants to add real-time collaboration \u2014 I think we should prioritize fixing existing bugs first, especially the crash on large files.\n\u2022 Follow up with marketing about the blog post deadline."
    },
    creative: {
      raw: "the morning light came through the window and it was that kind of golden warm light you know the kind that makes everything look soft and the dust particles were floating in it like tiny stars and she sat there with her coffee just watching them drift",
      clean: "The morning light filtered through the window \u2014 that warm, golden kind that softens everything it touches. Dust motes drifted through the beam like tiny stars. She sat with her coffee, watching them float."
    }
  };

  const rawTextEl = document.querySelector('.demo-raw-text');
  const cleanTextEl = document.querySelector('.demo-clean-text');
  const cleanLayer = document.querySelector('.demo-clean');
  const shimmer = document.querySelector('.demo-shimmer');
  const connector = document.querySelector('.demo-connector');
  const connectorLabel = document.querySelector('.connector-label');
  const rightPanel = document.querySelector('.demo-panel-right');
  const tabs = document.querySelectorAll('.demo-tab');
  const caret = document.querySelector('.demo-caret');
  const recordingOverlay = document.querySelector('.recording-overlay');
  const wavePath = document.querySelector('.wave-path');
  const overlayTimer = document.querySelector('.overlay-timer');
  const rightHeader = document.querySelector('.panel-header-right');

  let animating = false;
  let currentTimers = [];
  let wavePhase = 0;
  let waveAnimFrame = null;
  let timerSeconds = 0;

  function clearTimers() {
    currentTimers.forEach(id => clearTimeout(id));
    currentTimers = [];
  }

  function delay(ms) {
    return new Promise(resolve => {
      const id = setTimeout(resolve, ms);
      currentTimers.push(id);
    });
  }

  function resetState() {
    clearTimers();
    rawTextEl.textContent = '';
    cleanTextEl.textContent = '';
    cleanLayer.classList.remove('visible');
    shimmer.classList.remove('active');
    connector.classList.remove('visible');
    rightPanel.classList.remove('transformed');
    rightHeader.classList.remove('active');
    caret.classList.remove('hidden');
    recordingOverlay.classList.remove('active');
    if (waveAnimFrame) {
      cancelAnimationFrame(waveAnimFrame);
      waveAnimFrame = null;
    }
    wavePhase = 0;
    timerSeconds = 0;
  }

  // Traveling wave animation (natural speech-like with random spikes)
  let randomOffsets = []; // Store random amplitude variations

  function initRandomOffsets() {
    // Generate random amplitude variations (simulate speech patterns)
    randomOffsets = [];
    for (let i = 0; i < 40; i++) {
      randomOffsets.push(Math.random() * 0.6 + 0.4); // 0.4 to 1.0 multiplier
    }
  }

  function animateWave() {
    if (!animating) return;

    wavePhase += 0.035; // SLOWER wave travel (more natural speech rate)

    // Generate wave path with random speech-like variations
    const numPoints = 40;
    const waveWidth = 44;
    const centerY = 13; // Half of 26px height

    let pathD = `M 0,${centerY}`;

    for (let i = 1; i < numPoints; i++) {
      const x = (i / (numPoints - 1)) * waveWidth;
      const progress = i / (numPoints - 1);

      // Taper at edges for natural look
      const taper = Math.sin(progress * Math.PI);

      // Base traveling wave (slower, smoother)
      const wave1 = Math.sin((i * 0.3) - wavePhase * 1.2);
      const wave2 = Math.sin((i * 0.5) - wavePhase * 0.8);

      // Add random variations to simulate natural speech amplitude
      const randomVariation = randomOffsets[i] || 0.7;

      // Combine waves with randomness for natural speech pattern
      const baseAmplitude = (wave1 + wave2 * 0.5) * 2.5;
      const amplitude = baseAmplitude * randomVariation * taper;

      const y = centerY + amplitude;
      pathD += ` L ${x},${y}`;
    }

    wavePath.setAttribute('d', pathD);

    // Occasionally regenerate random offsets for variation (every ~2 seconds)
    if (Math.floor(wavePhase) % 60 === 0 && wavePhase > 1) {
      initRandomOffsets();
    }

    // Update timer display (slower increment for slower wave)
    const elapsedSeconds = Math.floor(wavePhase / 2.5);
    if (elapsedSeconds !== timerSeconds) {
      timerSeconds = elapsedSeconds;
      const mins = Math.floor(timerSeconds / 60);
      const secs = timerSeconds % 60;
      overlayTimer.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    waveAnimFrame = requestAnimationFrame(animateWave);
  }

  async function typeText(el, text) {
    // Type in chunks (~3 chars at a time for 3s total) — Natural talking speed
    const chunkSize = 3;
    const totalChunks = Math.ceil(text.length / chunkSize);
    const interval = Math.floor(3000 / totalChunks);

    for (let i = 0; i < text.length; i += chunkSize) {
      if (!animating) return;
      el.textContent = text.slice(0, i + chunkSize);
      await delay(interval);
    }
    el.textContent = text;
  }

  async function playSequence(personaKey) {
    if (animating) {
      resetState();
      // Small gap so reset visually registers
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
    }

    animating = true;
    const persona = PERSONAS[personaKey];

    resetState();

    // === 12-SECOND SMOOTH FLOW ===

    // Phase 0: Initial pause - overlay appears, wave starts (0-600ms)
    recordingOverlay.classList.add('active');
    wavePhase = 0;
    timerSeconds = 0;
    overlayTimer.textContent = '0:00';
    initRandomOffsets(); // Initialize random speech variations
    animateWave(); // Start wave animation
    await delay(600);
    if (!animating) return;

    // Phase 1: Type at natural talking pace (600-3600ms) — 3 seconds
    await typeText(rawTextEl, persona.raw);
    if (!animating) return;

    // IMMEDIATELY stop wave when typing finishes
    if (waveAnimFrame) {
      cancelAnimationFrame(waveAnimFrame);
      waveAnimFrame = null;
    }

    // Phase 2: Pause after speaking - recording stops (3600-4500ms) — 900ms
    recordingOverlay.classList.remove('active');
    caret.classList.add('hidden');
    connector.classList.add('visible');
    await delay(900);
    if (!animating) return;

    // Set clean text (handle newlines for Notes)
    if (persona.clean.includes('\n')) {
      cleanTextEl.innerHTML = persona.clean.replace(/\n/g, '<br>');
    } else {
      cleanTextEl.textContent = persona.clean;
    }

    // Phase 3: Shimmer starts (4500ms)
    shimmer.classList.add('active');
    await delay(150); // Tiny delay so shimmer is visible
    if (!animating) return;

    // Phase 3b: Clean text POPS IN immediately during shimmer (4650ms)
    cleanLayer.classList.add('visible');
    rightHeader.classList.add('active');
    await delay(1350); // Shimmer continues over visible text (total 1.5s shimmer)
    if (!animating) return;

    // Phase 4: Panel glow - transformation complete (6000-8000ms) — 2 seconds
    rightPanel.classList.add('transformed');
    await delay(2000);
    if (!animating) return;

    // Phase 6: Rest state - compare before/after (8000-12000ms) — 4 seconds
    await delay(4000);

    animating = false;
  }

  // Tab click handler
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      if (tab.classList.contains('active') && !animating) {
        // Replay current
        playSequence(tab.dataset.tab);
        return;
      }
      tabs.forEach(t => {
        t.classList.remove('active');
        t.setAttribute('aria-selected', 'false');
      });
      tab.classList.add('active');
      tab.setAttribute('aria-selected', 'true');
      playSequence(tab.dataset.tab);
    });
  });

  // Auto-play on load
  playSequence('developer');
</script>
